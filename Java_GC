垃圾回收

reference from : https://www.nowcoder.com/questionTerminal/669b88c90a7545e6aa556beef815c43f
                 https://www.nowcoder.com/questionTerminal/d8eab06913084e42b515633604eef7cd

1. 垃圾回收的目的和条件？
垃圾回收的目的是识别并且丢弃不再使用的对象来释放和重用资源。
触发主GC（Garbage Collector，垃圾回收）的条件：
  （1）当应用程序空闲时，即没有应用线程在运行时，GC会被调用。
  （2）Java堆内存不足时，GC会被调用

2. System.gc() vs Runtime.gc()

这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。
java.lang.System.gc()只是java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。

3. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？

1）垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；
2）GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。
   只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。

4. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
   不会，在下一个垃圾回收周期中，这个对象将是可被回收的。

5. 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？

   (1)
      吞吐量(throughput)收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。
      而串行(serial)收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

   (2)
      串行GC：整个扫描和复制过程均采用单线程的方式，相对于吞吐量GC来说简单；适合于单CPU、客户端级别。
      吞吐量GC：采用多线程的方式来完成垃圾收集；适合于吞吐量要求较高的场合，比较适合中等和大规模的应用程序。

6. 在Java中，对象什么时候可以被垃圾回收？

   当一个对象到GC Roots不可达时，在下一个垃圾回收周期中尝试回收该对象，如果该对象重写了finalize()方法，
   并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写finalize()方法或者已经执行过这个方法，也自救失败，该对象将会被回收。

7. JVM的永久代中会发生垃圾回收么？

   垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区
   (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)
